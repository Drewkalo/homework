[[_TOC_]]

## Цели и структура занятия

***Тэги**: git, github*

 На протяжении предыдущих занятий вы создавали код для работы с RaspberryPi, который хранится на ваших малинках. Хорошо, если он хранится в одном месте и за два занятия никуда и не потерялся. Переписывать код каждый раз заново, даже если вы знаете как его написать, не самый эффективный подход. Лучше всего пользоваться предыдущими наработками и вносить в них изменения или добавлять новый код. Самый надёжный и эффективный способ хранить и изменять код — **репозитории в облаке.** 
 
 Репозиторий поможет вам следить за версиями проекта, создавать разные ветки развития проекта, откатываться до старых версий.

 Облако поможет вам не потерять код, делиться им с другими людьми и разрабатывать проекты вместе с ними. Облачным хранилищем кода на этом занятии будет выступать **GitHub**.

 Система хранения Git практически стала стандартом в информационных технологиях, и опыт работы с Git требуется в очень многих областях. Поэтому чем раньше вы начнёте работать с Git, тем раньше приобретете важный и полезный навык!

**Нужно научиться:**
* генерировать ssh ключ
* пользоваться ssh ключом
* создавать репозиторий на сайте GitHub
* клонировать репозиторий
* коммитить
* создавать ветки
* сливать ветки
* отправлять изменения на сервер
* получать изменения с сервера

## Полезные материалы

Материалы к этому занятию покрывают основы работы с системой Git, по которой в интернете уже существует масса курсов, статей и гайдов. Мы постарались собрать самое полезное и нужное в нашем материале. Но если вам этого недостаточно, то ниже представлены полезные ссылки, по которым вы сможете узнать гораздо больше:

[Официальная страница git-scm](https://git-scm.com/)

[Онлайн-книга по работе с Git](https://git-scm.com/book/ru/v2) — информацию по занятию взята из этой книги

[Онлайн-урок по Git](https://githowto.com/ru) — самый эффективный способ понять как работать с Git

## Теория

### Git

**Git** — это распределенная система контроля версий. Система Git была создана Линусом Торвальдсом в 2005 году во время разработки ядра Linux, и решала одну конкретную задачу: совместная разработка кода ядра Linux. До Git командой разработки использовалась BitKeeper, но столкнувшись с проблемами при его использовании, Линус Торвальдс решил написать свою систему контроля версий.

[Первый коммит в системе git в репозиторий ядра Linux](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=v2.6.13-rc3&id=1da177e4c3f41524e886b7f1b8a0c1fc7321cac2)::[Tag](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/log/?h=v2.6.12-rc2)

![linux-kernel](images/linux-kernel-git-init.png){width=50%}

Давайте разберемся и поймём, что же такое *распределенная система контроля версий?* Для этого нам надо понять, какие еще системы контроля версий бывают.

* **Локальные системы контроля версий (ЛСКВ)**
Некоторые люди в качестве метода контроля версий применяют копирование файлов в отдельную директорию,возможно даже в директорию с отметкой по времени для большего контроля. Данный подход всё ещё очень популярен и распространён. Изменения сохраняются в виде наборов патчей, где каждый патч датируется и получает отметку времени. Таким образом, если код перестаёт работать, наборы патчей можно совместить, чтобы получить исходное состояние файла.

* **Централизованные системы контроля версий (ЦСКВ)**
ЦСКВ были созданы для решения проблемы взаимодействия с другими разработчиками. Такие системы имеют единственный сервер, содержащий все версии файлов, и некоторое количество клиентов, которые получают файлы из этого централизованного хранилища и там же их сохраняют. Тем не менее, такой подход имеет существенный недостаток — выход сервера из строя обернётся потерей всех данных.

* **Распределённые системы контроля версий (РСКВ)**
РСКВ избавили пользователей от недостатка ЦСКВ, клиенты РСКВ не просто скачивают снимок всех файлов (состояние файлов на определённый момент времени), а полностью копируют репозиторий. Это значит, что у каждого клиента есть копия всего исходного кода и внесённых изменений. В этом случае, если один из серверов выйдет из строя, любой клиентский репозиторий может быть скопирован на другой сервер для продолжения работы. Ещё одним преимуществом РСКВ является то, что они могут одновременно взаимодействовать с несколькими удалёнными репозиториями, что означает, что вы можете параллельно работать над несколькими проектами.

Получается, что в этой системе мы можем хранить набор разных версий кода и обмениваться всем набором изменений с сервером.

#### Определения

Нам необходимо ввести некоторые определения для работы с Git, которые будут справделивы для всех операционных систем.

**Локальная база данных git, локальный репозиторий (repository)** — это набор файлов, в которых хранится информация о всех версиях файлов директории, в которой создан репозиторий. Файлы локальной базы данных хранятся в директории (папке) **.git**. 
> ⚠️ Очень важно НЕ вносить изменения в эту папку вручную !

**branch (ветка)** — перемещаемый указатель на фиксированную версию в локальном или удалённом репозитории. По умолачанию создаётся ветка **master** или **main**

Состояние файлов:

**modified (модифицированный)** — файл, который изменил содержание по отношению к предыдующей зафиксированной версии, но еще не проиндексирован;

**staged (индексированный)** — файл, отмеченный для включения в следующую версию;

**commited (зафиксированный)** — файл, зафиксированный в локальной базе данных в данной версии;

Действия:

**commit (фиксирование версии, коммит)** — добавление проиндексированных файлов в локальную базу данных;

**merge (слияние)** — добавление изменений одной фиксированной версии к другой;

**clone (клонирование)** — копирует удаленную базу данных на локальный компьютер, тем самым создавая локальную базу данных;

**push (отправка)** — отправляет версий из вашего локального репозиторий на удалённый репозиторий;

**fetch (получение)** — получает информацию о зафиксированных версиях из удаленного репозитория;

**pull (вытягивание)** — получает информацию о зафиксированных версиях и выполняет слияние текущей локальной версии и последней из полученных версий из уделнного репозитория


### Сервера Git. GitHub

Если вы разрабатываете проект в команде, то хотелось бы, чтобы все участники команды имели одновременный доступ к репозиторию. Проще всего это сделать, разместив ваш код на сервере, имеющем доступ к глобальной сети Интернет.

На сервере должен хранится репозиторий, такой же как и у вас на локальном компьютере, а доступ к нему должен осуществляться при помощи разных протоколов: SSH, HTTP, HTTPS.

Но для этого у вас должен быть в распоряжении такой сервер. Более того, вы должны уметь его настраивать, поддерживать и следить за тем, чтобы проходящий мимо кот не нажал на кнопку выключения питания в самый ответственный момент.

Ответственность за хранение данных можно переложить на сервисы, которые занимаются хранением репозиториев, например **GitHub**.

![GitHub](images/github.png)

Он позволяет создавать репозитории, давать людям доступ к нему, определять, кто может изменять код в вашем репозитории, создавать команды, задачи, ставить лайки (в случае репозиториев это звезды). В общем, GitHub уже давно стал больше чем место, где хранится код. Это целая экосистема для разработки проектов, которая помогает командам создавать классные продукты и делиться ими со всем миром, а мир может им помочь сделать их продукт еще лучше.


Помимо **GitHub** есть система **GitLab**, которую вы можете установить на свой сервер. Минус в том, что вы должны уметь обслуживать сервер, плюс в том, что все остальные задачи (подобные тем, что решает **GitHub**) уже решены в **GitLab**.

 ![GitLab](images/gitlab.png) 

### SSH

Мы поняли, что у нас есть репозиторий Git. Этот репозиторий хранится на некотором сервере (вашем личном, или GitHub). Как же безопасно обмениваться с репозиторием на этом сервере вашими изменениями версий? Проблема безопасного обмена информацией с сервером решается при помощи протокола SSH. 

**SSH** (*Secure SHell*, защищенная оболочка) — это протокол, который позволяет получать доступ к командам операционной системы по зашифрованному каналу данных. То есть те, команды которые вы выполняете в терминале у себя на локальном компьютере (`ls`, `cd` и т.д.), вы можете так же при помощи этого протокола выполнить на любом другом компьютере если будете иметь к нему доступ. 

Доступ можно получить либо зная имя пользователя и пароль, либо при помощи SSH RSA-ключа. Второй способ является предпочтительным, и на данный момент подключится к GitHub только на основании логина и пароля невозможно.

Чтобы подключится к серверу, вам необходимо создать пару **RSA-ключей**: публичный и приватный. **Публичный ключ** вы можете отправлять на сервера, к которым будете подключаться. **Приватный ключ** вы должны держать в секрете, на него можно даже установить пароль, так что даже если *кто-то* скопирует ваш приватный ключ, то этот *кто-то* не сможет им воспользоваться.

Шифрование данных в SSH происходит в два этапа. При подключении к серверу при помощи ассимитричного шифрования вы обмениваетесь *сеансовым ключом* (такой ключ, которым будут шифроваться данные на протяжении сеанса), который сервер зашифровывает публичным ключом, а вы расшифровываете приватным. После обмена *сеансовым ключом* все сообщения шифруются именно им при помощи симметричного шифрования. Вы никак не влияете на *сеансовый ключ*, эти подробности нужны лишь для общего понимания принципов работы SSH.

## Практика

### Установка Git

[Описание установки для всех систем в онлайн-книге](https://git-scm.com/book/ru/v2/%D0%92%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%A3%D1%81%D1%82%D0%B0%D0%BD%D0%BE%D0%B2%D0%BA%D0%B0-Git)

#### Linux (RaspberryPi)

По умолчанию в Linux уже установлен git. Работа с Git осуществляется в терминале.

#### Mac OS

Самый простой способ установить Git, это воспользоваться менеджером пакетов Homebrew. 

1. Откройте окно терминала, набрав Command + Пробел, чтобы открыть Spotlight, а затем введите слово "терминал" в поле поиска. Выберите программу "Терминал", нажав Enter.

2. Теперь скопируйте и вставьте следующую команду в окно терминала, чтобы установить Homebrew.

``/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"``

3. Нажмите Return и разрешить установку Homebrew. Когда она завершится, у вас будет установлен Git в Mac OS, поскольку он является неотъемлемой частью Homebrew.

Работа с Git осуществляется в терминале.

#### Windows

[Ссылка на скачивание установочного файла](https://git-scm.com/download/win)

Работа будет происходить в терминале Git Bash. Эту программу можно найти в меню "Пуск".

### Основные команды git

#### Начало работы

При работе в Linux или MacOS необходимо открыть терминал. При работе в Windows необходимо запустить программу **Git Bash**, только в ней команды будут совпадать с командами из Linux и MacOS.

Если вы только установили Git, то необходимо сообщить своё имя и email системе Git, чтобы она подписывала ваши коммиты.

```
git config --global user.name "Имя Фамилия"
git config --global user.email "имя.фамилия@phystech.edu"
```

Также можно указать, каким текстовым редактором вы хотите пользоваться при редактировании текста коммитов. Если вы не знаете, что такое Vim, то лучше всего ввести следующую строчку, тогда вы выберете редактор nano, который более дружелюбен к новым пользователям:

```
git config --global core.editor nano
```

Теперь мы готовы создать репозиторий и сделать первый коммит. Для этого необходимо создать папку, в которой будет располагаться репозиторий. Репозиторий создаётся при помощи команды:

```git init```

Вот как выглядят выше описанные действия в командной строке:

![git-init](images/git-init.png){width=50%}

#### Первый коммит

Создадим в репозитории текстовый файл README.md, напишем в него: "Hello, World!" и закоммитим.

Создать файл в терминале можно при помощи команды:
``` nano README.md ```

Это команда создаст файл и откроет его в текстовом редакторе **nano**. Этот текстовый редактор встроен в терминал, у него нет графического представления. Так что после выполнения программы ваше окно терминала будет выглядеть примерно вот так:

![nano-readme](images/nano-readme.png){width=50%}

Просто напишите текст и нажмите `Ctrl+W`, чтобы записать файл на диск. Нажмите `Ctrl+X`, чтобы выйти.

Теперь посмотрим статус нашего репозитория:

``` git status ```

![git-status](images/git-status.png){width=50%}

Команда статус сообщает нам, что мы находимся в ветке *master*. Что подготовленных для фиксирования версии файлов. И файл Readme.md непроиндексирован.

Проиндексируем файл Readme.md при помощи команды

```git add Readme.md```

![git-add](images/git-add.png){width=50%}

Теперь мы видим, что наши изменения проиндексированы и готовы для комита. Чтобы выполнить коммит (зафиксировать текущую версию):

```git commit```

Если вы поменяли редактор в начале работы на *nano*, то вам откроется окно текстового редактора, в котором необходимо написать сообщение к git коммиту. После этого сохранить сообщение при помощи `Ctrl-O` и закрыть при помощи `Ctrl-X`. Можем опять спросить статус и увидеть, что модифицированных файлов в текующем состоянии репозитория нет.

![git-commit](images/git-commit.png){width=50%}

#### Где коммит?

Чтобы точно убедится, что наша версия появилась в репозитории выполним команду (**Если лог длинный, чтобы выйти из просмотра лога ввведите сначала `:`, потом нажмите `q`**):

```git log```

![git-log](images/git-log.png){width=50%}

Эта команда выводит лог репозитория, а точнее описание нескольких последних комитов (зафиксированных версий) в репозитории. Также можно увидеть кто сделал комит и когда.

Важно, что нам выводится **хэш** комита. Хэши не повторяются и однозначно указывают на конкретную зафиксированную версию в репозитории. Это будет важно, когда мы захотим переключаться на конкретный коммит, сделать это можно только по хэшу.

Дальше идёт надпись `HEAD -> master`. `HEAD` — это указатель на ту версию, относительно которой будут фиксироваться изменения. А конкретная надпись означает, что следующие изменения будут фиксироваться относительно последней версии в ветке `master`

Если ваш репозиторий слишком большой, то лучше воспользоваться командой:

```git log —all —decorate —oneline —graph```

Запомнить эту команду поможет мем:

![git-log-adog](images/git-log-adogjpg.jpg){width=50%}

Можно также сохранить короткое имя для этой команды:

```git config --global alias.adog "log --all --decorate --oneline --graph"```

И вызывать ее командой:

``` git adog```

Поздравляем! Теперь вы можете фиксировать разные версии ваших файлов и не переживать, что что-то сломается. Но пока мы научились делать это только локально и в одной ветке. Дальше мы разберемся как нам работать с удалённым репозиторием на сервере и разными ветками.

### Работа с SSH-ключами в терминале

#### Создаём ключи

Прежде чем начать работать в GitHub нам нужно создать публичный и приватный ключ. Делается это при помощи программы-генератора ключей, например `ssh-keygen`. Но сначала давайте посмотрим, есть ли у нас уже созданные ключи:

```ls ~/.ssh```

Команда `ls` показывает файлы и папки в директории. Символ `~` является указателем на домашнюю директорию, это такая директория, в которой хранятся данные пользователя. Дальше указывается путь папки `.ssh` относительно домашней директории, в этой папке сохраняются ваши созданные ключи, а также другие настройки ssh-клиента.

Давайте создадим наш первый ключ при помощи команды:

```ssh-keygen -t ed25519 -C "имя.фамилия@phystech.edu"```

Где `ed25519` это просто формат ключа, а после ключа `-C` идёт ваш email.

Программа предложит вам переименовать ключ, можно отказаться (его можно переименовать позже) и попросит ввести пароль для ключа (его можно оставить пустым). Теперь если вы еще раз выполнить команду ```ls ~/.ssh```, то должны увидеть там два файла `id_ed25519` и  `id_ed25519.pub`. Это просто текстовое представление некоторого очень большого числа. Вывести значение ключа на экран можно при помощи команды:

``` cat ~/.ssh/id_ed25519.pub ```

#### Добавляем ключи в агента SSH

Ключи созданы, но наш клиент SSH не знает какой ключ использовать для подключения. Эту информацию клиенту SSH может предоставить программа `ssh-agent`. Чтобы запустить ее нужно выполнить в терминале команду:

```eval "$(ssh-agent -s)"```

А после добавить в агента ваш ключ при помощи команды:

```ssh-add ~/.ssh/id_ed25519```
Последние две команды необходимо выполнять каждый раз при перезапуске терминала.

Отлично! Теперь мы готовы получать данные из удаленного репозитория.

### Работа в удаленном репозитории. GitHub

#### Добавляем ключ на GitHub

Сначала вам необходимо создать учетную запись на сайте GitHub. Надеюсь, что вы справитесь с этим сами.

После того как вы создали учётную запись необходимо добавить ваш публичный ключ в настройки пользователя. Для этого наведите на вашу иконку в правом верхнем углу, выберите пункт `Settings`, найдите слева пункт `SSH and GPG keys`, нажмите на кнопку `New SSH key`.

Откроется окно, в котором можно ввести название в поле `Title`. В поле `Key` нужно вставить публичный ключ. Его можно получить при помощи команды на вашем компьютере `cat ~/.ssh/id_ed25519.pub`. Скопируйте ключ из терминала, и вставьте его, после чего нажмите `Add SSH key`.

После этого ключ должен отражаться в списке ключей. Чтобы проверить правильно ли вы всё сделали вызовите команду:

``` ssh -T git@github.com ```

Она должна вернуть

```Hi <username>! You've successfully authenticated, but GitHub does not provide shell access.``` 

#### Создаём репозиторий на GitHub

В правом верхнем углу наводим на плюсик и выбираем `New Repository`. Придумываем название, описание, делаем его публичным и нажимаем `Create repository`. Теперь во вкладке `Your Repositories` под вашей иконкой, должен появится ваш репозиторий, выберете его в списке. Когда он откроется нажмите на кнопку `Code` в ней выбираем вкладку `SSH` в строке ниже есть строчка, которая начинается с `git@github.com...` — это адрес вашего репозитория по протоколу SSH. Скопируйте ее.

#### Клонируем репозиторий

Если вы находитесь в папке с другим репозиторием, то выйдите из нее. Не стоит клонировать репозиторий в другой репозиторий!

Теперь необходимо получить созданный репозиторий. Это можно сделать при помощи команды, где в `<url>` вставьте адрес репозитория:

```git clone <url>```

После этого в текущей папке появится папка с названием вашего репозитория. Отлично!

Если вы всё это время повторяли действия описанные выше, то пришла пора перейти к выполнению заданий, так как проще всего разобраться с Git на практике!

## Задания

Инструменты
* Git
* GitHub
* Markdown

### Задача №1. Первый коммит
Создать репозиторий, клонировать его, сделать комит и отправить изменения на сервер

* создать аккаунт на сайте GitHub.com
* настроить двухфакторную аутентификацию
* добавить свою фотографию в аккаунт
* создать репозиторий, назвав его своей фамилией
* дать другу доступ к репозиторию
* создать ssh-ключ
* добавить публичный ключ в свой аккаунт на GitHub
* запустить ssh-agent (только под Windows)
* добавить приватный ключ в ssh-agent
* клонировать свой новый репозиторий на рабочий компьютер: ```git clone git@github.com:username/repository.git```
* добавить в репозиторий файл ```git-how-to.md```
* описать на языке разметки markdown инструкции для себя:
    * как создать ssh ключ
    * как добавить ключ в аккаунт на GitHub
    * как склонировать репозиторий
* проверить статус репозитория: ```git status```
* подготовить новый файл для комита: ```git add git-how-to.md```
* проверить статус репозитория: ```git status```
* сделать комит:```git commit -m “initial commit”```
* отправить изменения на сервер: ```git push```

### Задача №2. Первая ветка
Клонировать репозиторий, создать ветку, сделать два комита, отпраивть изменения на сервер

* принять приглашение друга на доступ к репозиторию, которое пришло на почту
* клонировать репозиторий друга на свой рабочий компьютер
* в репозитории друга создать ветку со своей фамилией: ```git branch surname```
* переключиться в новую ветку: ```git checkout surname```
* добавить в репозиторий файл ```branch-how-to.md```
* написать в новом файле пару строк о том, как пользоваться ветками
* проверить статус репозитория: ```git status```
* подготовить новый файл для комита: ```git add branch-how-to.md```
* проверить статус репозитория: ```git status```
* сделать комит: ```git commit -m “branch instructions”```
* отправить изменения на сервер: ```git push```
* дополнить файл ```branch-how-to.md``` полной инструкцией:
    * как создать ветку
    * как переключиться в ветку
    * как отправить ветку на сервер
* проверить статус репозитория: ```git status```
* подготовить новый файл для комита: ```git add branch-how-to.md```
* проверить статус репозитория: ```git status```
* сделать комит: ```git commit -m “full branch instruction”```
* отправить изменения на сервер: ```git push```

### Задача №3. Первое слияние веток
Получить изменения с сервера, слить ветки, сделать ещё один комит

* перейти в свой репозиторий
* получить с сервера изменения во всех ветках: ```git fetch```
* посмотреть все ветки: ```git branch —all```
* переключиться в ветку друга, чтобы создать её локально: ```git checkout surname```
* посмотреть все ветки: ```git branch —all```
* переключиться в основную ветку: ```git checkout master```
* обьединить ветку друга с основной веткой: ```git merge surname```
* отправить изменения на сервер: ```git push```
* посмотреть историю репозиория: ```git log```
* добавить в репозиторий файл ```merge-how-to.md```
* описать на языке разметки markdown инструкции для себя:
    * как получить ветку с сервера
    * как слиять одну ветку с другой
    * что сделать после слияния веток
* проверить статус репозитория: ```git status```
* подготовить новый файл для комита: ```git add .```
* проверить статус репозитория:``` git status```
* сделать комит: ```git commit -m “merge instruction”```
* отправить изменения на сервер: ```git push```

### Задача №4. Второй репозиторий
Создать репозиторий, добавить в него свои скрипты

* создать в своём аккаунте репозиторий get
* клонировать репозиторий
* скопировать в папку репозитория свои Python-скрипты
* сделать комит изменений
* отправить изменения на сервер

Формат сдачи
В качестве ответа нужно вписать HTTPS ссылки на три репозитория

* репозиторий в вашем GitHub аккаунте, названный вашей фамилией
* репозиторий в GitHub аккаунте вашего друга, в котором вы делали ветку
* репозиторий get в вашем GitHub аккаунте

Критерии оценки
Задания выполняются последовательно
Каждая решённая задача повышает оценку
* Задача №1 - максимум уд(3)
* Задачи №1 и №2 - максимум хор(6)
* Задачи №1, №2 и №3 - максимум отл(8)
* Задачи №1, №2, №3 и №4 - максимум отл(10)
