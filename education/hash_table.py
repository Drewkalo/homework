#состоит из массива и хеш_функции, отображающей строки в числа. В массиве же хранит данные. В среднем, любые операции происходят постоянно(мгновенно), независимо от размера таблицы O(1). 
#Используется в преобразовании DNS(имя адреса в IP)
#Коллизии - случай, когда двум разным значениям присваивается 1 ключ.
#Один из способов устранить коллизии - заводить связанный список в ячейке, где получилось совпадение.
#Другой вариант, правильно подобрать хеш_функцию(чтобы распределяла равномерно элементы по ячейкам)
#Коэффициент заполнения = колво элементов в таблице / общее колво элементов
'''
Простое равномерное хеширование уязвимо к плохим ключам, которые могут привести к большому количеству коллизий
(ситуации, когда разные ключи имеют один и тот же хеш-код). Универсальные семейства хеш-функций решают эту проблему. 
Это набор хеш-функций, выбираемая случайным образом из которого функция обладает свойством: 
вероятность коллизии для любых двух различных ключей мала и не зависит от выбора ключей. 
Это гарантирует, что даже при наличии неблагоприятного распределения ключей вероятность коллизий остается низкой в среднем.

Обработка коллизий
Цепочки (Separate Chaining): В каждой ячейке хеш-таблицы хранится не один элемент, а список (обычно связный список) 
элементов с одинаковым хеш-кодом. Это простой и эффективный метод.
Открытая адресация (Open Addressing): Если ячейка занята, алгоритм пытается найти следующую свободную ячейку, 
используя определенную стратегию поиска (линейная, квадратичная, двойное хеширование).

Операции
Добавление: Вычисляется хеш-код ключа. В зависимости от метода обработки коллизий, элемент добавляется либо в список (цепочки), 
либо в найденную свободную ячейку (открытая адресация).
Удаление: Вычисляется хеш-код ключа. Элемент удаляется из списка (цепочки) или 
помечается как удаленный (открытая адресация, чтобы не нарушать поиск при открытой адресации).
Поиск: Вычисляется хеш-код ключа. Проверяется соответствующая ячейка. 
В случае цепочек просматривается список, в случае открытой адресации — осуществляется поиск по таблице до тех пор, 
пока не будет найден элемент или свободная ячейка (что означает отсутствие элемента).

Перехеширование (Rehashing):
Когда хеш-таблица заполняется (коэффициент заполнения превышает определенный порог), производительность операций поиска, 
добавления и удаления падает. В этом случае выполняется перехеширование: создается новая, более большая хеш-таблица, 
и все элементы из старой таблицы перехешируются и копируются в новую.

 Обоснование асимптотики:

• Идеальное хеширование: При идеальном хешировании (без коллизий) среднее время операций поиска, вставки и удаления — O(1) (константное время). 
Это связано с тем, что мы непосредственно обращаемся к ячейке по индексу.

• Цепочки: При использовании цепочек и равномерном распределении ключей среднее время поиска, вставки и удаления — O(1 + α), 
где α — коэффициент заполнения (отношение количества элементов к размеру таблицы). Если α держится постоянной (например, α ≤ 0.7), 
время операций остается O(1).

• Открытая адресация: При равномерном распределении ключей и использовании эффективных стратегий поиска (например, двойного хеширования), 
среднее время операций — O(1/(1-α)). При небольшом α это приблизительно O(1). Однако, при α, приближающемся к 1, производительность резко падает.м

Худший случай — O(n) (линейное время), обычно в случае большого количества коллизий. 
'''
phone_book = {}
phone_book["jenny"] = 8675309
phone_book["emergency"] = 911

voted = {}
value = voted.get("tom") #true or None
def check_vote(name):
    if voted.get(name) != None:
        print("kick them out")
    else:
        voted[name] = True
        print("let them vote")
check_vote("tom")
check_vote("alice")
check_vote("tom")

