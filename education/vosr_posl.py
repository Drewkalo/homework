'''
Вариант за O(n log n)
В массив d мы записываем минимальный элемент, на который заканчивается подпоследовательность длины [i].

Теперь рассмотрим очередной элемент ai. Его можно добавить в конец любой возрастающей подпоследовательности, которая заканчивается числом,
меньшим, чем ai. Если есть возрастающая подпоследовательность длины k, которая заканчивается каким-то значением x, 
то есть F(k) = x, при этом x < ai, то возможно построить последовательность длины k+1 с последним элементом, равным ai, 
добавив его в конец подпоследовательности длины k. При этом это должно приводить к улучшению значения F(k + 1), 
то есть F(k + 1) должно быть не меньше, чем ai. Это означает, что необходимо среди элементов списка F найти такое значение k, 
что F(k) < ai, F(k + 1) >= ai, после чего необходимо установить F(k + 1) = ai . Это можно сделать при помощи функции двоичного поиска LowerBound, 
которая позволяет в списке F найти первое значение, не меньшее, чем ai, после чего ему необходимо присвоить ai. Заметим, 
что при этом монотонность значений в списке F сохраняется, что делает оправданным двоичный поиск.

Для восстановления ответа будем поддерживать заполнение двух массивов: pos[] и prev[]. В pos[i] будем хранить индекс элемента, 
на который заканчивается оптимальная подпоследовательность длины i, а в prev[i]— позицию предыдущего элемента для a[i].
'''
def longest_increasing_subsequence(nums):
    n = len(nums)
    if n == 0:
        return []
                    #выполняется за O(n^2)
    dp = [1] * n  #Длина наибольшей возрастающей подпоследовательности, заканчивающейся на nums[i]
    predecessors = [-1] * n # Индекс предыдущего элемента в наибольшей возрастающей подпоследовательности

    max_length = 1
    max_index = 0

    for i in range(1, n):
        for j in range(i):
            if nums[i] > nums[j] and dp[i] < dp[j] + 1:
                dp[i] = dp[j] + 1
                predecessors[i] = j

        if dp[i] > max_length:
            max_length = dp[i]
            max_index = i

    # Реконструкция наибольшей возрастающей подпоследовательности
    lis = []
    current_index = max_index
    while current_index != -1:
        lis.append(nums[current_index])
        current_index = predecessors[current_index]

    return lis[::-1] # Переворачиваем список, чтобы получить возрастающую последовательность


nums = [10, 9, 2, 5, 3, 7, 101, 18]
result = longest_increasing_subsequence(nums)
print(f"Наибольшая возрастающая подпоследовательность: {result}") # Вывод: [2, 3, 7, 101]

