'''
 O(mn)
Расстояние Левенштейна - метрика cходства между двумя строковыми последовательностями. 
Чем больше расстояние, тем более различны строки. Для двух одинаковых последовательностей расстояние равно нулю.
Рекуррентное соотношение:

Для i > 0 и j > 0:

`D[i][j] = min(
  D[i-1][j] + 1, // Удаление
  D[i][j-1] + 1, // Вставка
  D[i-1][j-1] + (a[i-1] != b[j-1]) // Замена (0, если символы одинаковы, 1 иначе)
)`

Это соотношение говорит, что минимальное расстояние между двумя префиксами строк достигается либо удалением символа из первой строки, 
либо вставкой символа во вторую, либо заменой символа.
'''
def levenshtein_distance(s1, s2):

    m = len(s1)
    n = len(s2)

    # Инициализация матрицы, колво строк = m + 1, колво столбцов = n + 1
    d = [[0] * (n + 1) for _ in range(m + 1)]
    #Заполняем числами, равным расстояниям левинштейна от пустых строк до слов
    for i in range(m + 1):
        d[i][0] = i
    for j in range(n + 1):
        d[0][j] = j

    # Вычисление расстояния, идём по строке слева направо, как дошли до конца, спускаемся на начало след.строки
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            #cost проверяет одинаковость букв на местах
            cost = 0 if s1[i - 1] == s2[j - 1] else 1
            d[i][j] = min(
                d[i - 1][j] + 1,  # Удаление
                d[i][j - 1] + 1,  # Вставка
                d[i - 1][j - 1] + cost  # Замена
            )
    print(d)
    return d[m][n]


# Пример использования:
string1 = "kitten"
string2 = "sitting"
distance = levenshtein_distance(string1, string2)
print(f"Расстояние Левенштейна между '{string1}' и '{string2}': {distance}")    
